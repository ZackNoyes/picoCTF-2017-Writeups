# Shells - 150 Points
How much can a couple bytes do? Use [shells](https://webshell2017.picoctf.com/static/085d0d631363eed11e17ffcc8bbcc84b/shells)! [Source](https://webshell2017.picoctf.com/static/085d0d631363eed11e17ffcc8bbcc84b/shells.c). Connect on shell2017.picoctf.com:61986

## Write-up
Obviously, you would have to write some shellcode, and also with a little bit of searching, one could use the `call` instruction to jump to the `win` function. However, many people who have attempted this problem didn't know that the `call` instruction is actually a relative address relative to the next instruction. The problem is, since this is excuted within an `mmap` call, and ASLR is enabled, we don't exactly know where the next instruction address will be. Instead, I decided to avert that and create a call to a register pointer. I used the following instructions:
```assembly
mov    eax,0x8048540
call   eax
```
Note that this is Intel syntax. The first instruction moved the address of the function `win`, which is 0x8048540 to the register `eax`. The next instruction calls the address of the function stored at `eax`. I then used `defuse.ca` to convert this into assembly. The  shellcode in hex is this: `"\xB8\x40\x85\x04\x08\xFF\xD0"`.

## Helpful References
https://defuse.ca/online-x86-assembler.htm#disassembly2